---
title: 排序算法
date: 2020-11-09 10:32:19
index_img: /resource/img/sort.png
category: 算法
tags: 排序算法
---

# 时间复杂度

时间复杂度：`T(n)=O(f(n))`
 
渐进时间复杂度（asymptotic time complexity）的概念，官方的定义如下：
若存在函数 f（n），使得当n趋近于无穷大时，T（n）/ f（n）的极限值为不等于零的常数，则称 f（n）是T（n）的同数量级函数。
记作 T（n）= O（f（n）），称O（f（n）） 为算法的渐进时间复杂度，简称时间复杂度。

 
如何推导出时间复杂度呢？有如下几个原则：  
 1.如果运行时间是常数量级，用常数1表示；   
 2.只保留时间函数中的最高阶项；  
 3.如果最高阶项存在，则省去最高阶项前面的系数。  
 


>常数阶O(1) < 对数阶O(logN) < 线性阶O(n) < 线性对数阶O(nlogN) < 平方阶O(n²) < 立方阶O(n³) < K次方阶O(n^k) < 指数阶(2^n)


# 快速排序

 >1.选择基准(一般取第一个)
 >2.从右往左查找比基准小的数，进行位置交换  
 >3.从左往右查找比基准大的数，进行位置交换  
 >4.重复执行2、3直到比较完成  
 >5.分别对两边重复执行1-4

````java
public class Sort {

    public static void quicksort(int[] arr,int left,int right){
        if (left < right) {
            int low = left, height = right, x = arr[left];
            while (low < height)
            {
                while(low < height && arr[height] >= x) // 从右向左找第一个小于x的数
                    height--;
                if(low < height)
                    arr[low++] = arr[height];

                while(low < height && arr[low] < x) // 从左向右找第一个大于等于x的数
                    low++;
                if(low < height)
                    arr[height--] = arr[low];
            }
            arr[low] = x;
            quicksort(arr, left, low - 1); // 递归调用
            quicksort(arr, low + 1, right);
        }
    }
}
````


# 直接插入排序

>1.分为有序和无序两段数组
>2.从无序中取第一个数插入有序半段中的适合位置
>3.重复执行2步骤直到无序数组为长度为零

`T(n)=O(n^2)`

```java
class Sort{
    public static void straightInsertSort(int[] arr){
        int j = 0;
        int tmp = 0;
        for (int i = 1; i < arr.length; i++) {
            if (arr[i]<arr[i-1]){//插入i-1前面
                tmp = arr[i];
                for (j = i - 1; j >= 0 && tmp < arr[j]; j--) {
                    arr[j+1] = arr[j];
                }
                arr[j+1] = tmp;
            }
        }
    }
}
```


# 选择排序

>1.在长度为N的无序数组中，第一次遍历n-1个数，找到最小的数值与第一个元素交换；

>2.第二次遍历n-2个数，找到最小的数值与第二个元素交换；

>3.第n-1次遍历，找到最小的数值与第n-1个元素交换，排序完成。

````java
public class Sort{
        public static void selectSort(int[] arr){
            int min;
            for (int i = 0; i < arr.length; i++) {
                min=arr[i];
                for (int j = i+1; j <arr.length; j++) {
                    if (arr[j]<min){
                        int tmp = arr[i];
                        min=arr[j];
                        arr[i]=arr[j];
                        arr[j]=tmp;
                    }
            }
       }
   }
}
````


# 希尔排序(Shell Sort)

数据序列1： 13-17-20-42-28 利用插入排序，13-17-20-28-42. Number of swap:1;
数据序列2： 13-17-20-42-14 利用插入排序，13-14-17-20-42. Number of swap:3;
如果数据序列基本有序，使用插入排序会更加高效。
     
基本思想：
    在要排序的一组数中，根据某一增量分为若干子序列，并对子序列分别进行插入排序。
    然后逐渐将增量减小,并重复上述过程。直至增量为1,此时数据序列基本有序,最后进行插入排序。
     
```java
public class Sort{
    public static void shellSort(int[] arr){

        int incre = arr.length;

        while (true){
            incre = incre>>1;
            for (int i = 0; i < incre; i++) {
                for (int j = i; j <arr.length ; j+=incre) {
                    for (int k = j; k >i ; k-=incre) {
                        if (arr[k]<arr[k-incre]){
                            int tmp = arr[k];
                            arr[k-incre]=arr[k];
                            arr[k]=tmp;
                        }else break;
                    }
                }
            }
            if (incre==1)break;
        }
    }
}
``` 

# 冒泡排序

基本思想：两个数比较大小，较大的数下沉，较小的数冒起来。

过程：

>比较相邻的两个数据，如果第二个数小，就交换位置。
从后向前两两比较，一直到比较最前两个数据。最终最小数被交换到起始的位置，这样第一个最小数的位置就排好了。
继续重复上述过程，依次将第2.3...n-1个最小数排好位置。

时间复杂度: `T(n)=O(n^2)`

```java
class Sort{
public static void BubbleSort(int [] arr){

     int temp;//临时变量
     for(int i=0; i<arr.length-1; i++){   //表示趟数，一共arr.length-1次。
         for(int j=arr.length-1; j>i; j--){

             if(arr[j] < arr[j-1]){
                 temp = arr[j];
                 arr[j] = arr[j-1];
                 arr[j-1] = temp;
             }
         }
     }
 }
}
```

# 归并排序

平均时间复杂度：`O(NlogN)`

基本思路:

>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。

>首先考虑下如何将将二个有序数列合并。这个非常简单，只要从比较二个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。

>>归并排序的效率是比较高的，设数列长为 N，将数列分开成小数列一共要 logN 步，每步都是一个合并有序数列的过程，时间复杂度可以记为 O(N)，故一共为 O(N*logN)。因为归并排序每次都是在相邻的数据中进行操作，所以归并排序在 O(N*logN) 的几种排序方法（快速排序，归并排序，希尔排序，堆排序）也是效率比较高的。

```java
public class Sort{
    /**
    *程序入口
    * @param arr
    */
    void MergeSort(int[] arr){
        int[] temp = new int[arr.length];
        mergeSort(arr,0,arr.length-1,temp);
    }
    /**
    * 递归
    * @param a
    * @param first
    * @param last
    * @param temp
    */
    public static void mergeSort(int[] a, int first, int last, int[] temp) {
        if (first < last) {
            int mid = (first + last) / 2;
            mergeSort(a, first, mid, temp);
            mergeSort(a, mid + 1, last, temp);
            mergeArray(a, first, mid, last, temp);
        }
    }
    /**
    * 合并数组
    * @param a
    * @param first
    * @param mid
    * @param last
    * @param temp
    */
    private static void mergeArray(int[] a, int first, int mid, int last, int[] temp) {
        int i = first, j = mid + 1;
        int m = mid, n = last;
        int k = 0;
        while (i <= m && j <= n) {
            if (a[i] <= a[j]) temp[k++] = a[i++];
            else temp[k++] = a[j++];
        }
        while (i <= m) temp[k++] = a[i++];
        while (j <= n) temp[k++] = a[j++];
        for (int l = 0; l < k; l++) a[first + i] = temp[i];
    }
}
```


# 堆排序

>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了



# 基数排序(RadixSort)

基本思想：
BinSort想法非常简单，首先创建数组A[MaxValue]；然后将每个数放到相应的位置上（例如17放在下标17的数组位置）；最后遍历数组，即为排序后的结果。








































