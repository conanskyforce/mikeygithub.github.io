---
title: JVM 知识汇总
date: 2020-05-19 17:19:15
index_img: /resource/img/jvm-1.jpg
category: JVM
tags: JVM
hide: true

---

# JVM 知识汇总

# 基本概念

```text
JVM是可运行Java代码的假想计算机，包括一套字节指令集，一组寄存器，一个栈，一个垃圾回收，堆和一个存储方法域．
Jvm是运行在操作系统上的他与硬件没有直接的交互．
```
![avatar](/resource/img/jvm.png)

# 运行过程

>我们都知道Java源文件，通过编译器能够生产相应的.Class文件，也就是字节码文件，而字节码文件又通过Java虚拟机中的解释器，编译成特定机器上的机器码

>Java源文件-->编译器-->字节码文件-->JVM-->机器码

>每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是Java为什么能够跨平台的原因，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动　就会存在多个虚拟机实例．程序退出或者关闭则虚拟机实例消亡，多个虚拟机实例之间数据不能共享<
 
![avatar](/resource/img/RunTimeJvm.png) 

# 线程

>这里所说的线程程序执行过程中的一个线程实体．JVM允许一个应用并发执行多个线程．`Hotspot JVM中的Java线程与原生操作系统线程有直接的映射关系`．当线程本地存储，缓冲区分配，同步对象，栈，程序计数器等准备好以后，就会创建一个操作系统图原生线程，并把他们分配到任何可以的CPU上．当原生线程初始化完毕，就会调用Java线程的run()方法．当线程结束时，会释放原生线程和Java线程的所有资源

### Hotspot JVM后台运行的系统线程主要有下面几个

![avatar](/resource/img/20200519184914.png) 

### JVM 内存区域

![avatar](/resource/img/20200519185041.png) 

>jvm内存区域主要分为线程私有区域［程序计数器，虚拟机栈，本地方法区］，线程共享区域［java堆，方法区］，直接内存．

`线程私有数据区域生命周期与线程相同，依赖用户线程的启动/结束而创建/销毁(在Hotspot VM内)，每个线程都与操作系统的本地线程直接映射，因此这部分内存区域的存/否跟随本地线程的生/死对应`

#### 线程共享区域随虚拟机的启动/关闭而创建/销毁

>直接内存并不是JVM运行时数据区的一部分,但也会被频繁的使用:在JDK1.4引入的NIO提供了基于Channel与Buffer的IO方式．他可以使用Native函数库直接分配堆外内存，然后使用DirectByteBuffer对象作为这个内存的引用进行操作，这样避免了在Java堆和Native中来回复制数据，因此在一场场景中可以显著提高性能．

![avatar](/resource/img/TIM图片20200519213321.png) 

# 程序计数器(线程私有)

>一块较小的内存空间，`是当前线程所执行的字节码的行号指示器`，每条线程都要有一个独立的程序计数器，这类内存也称为`线程私有`的内存．

>正在执行Java方法的话，计数器记录的是虚拟机字节码指令的地址(当前指令的地址)．如果还是Native方法则为空．

>这个内存区域是　唯一一个在虚拟机中没有规定任何OutOfMemoryError情况的区域

# 虚拟机栈(线程私有)

>是描述Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表，操作数栈，动态链接，方法出口等信息．每一个方法从调用直至执行完成的过程，就对应着一个在虚拟机栈中入栈到出栈的过程

>栈帧( Frame)是用来存储数据和部分过程结果的数据结构,同时也被用来处理动态链接(Dynamic Linking)、 方法返回值和异常分派( Dispatch Exception)。栈帧随着方法调用而创建,随着方法结束而销毁——无论方法是正常完成还是异常完成(抛出了在方法内未被捕获的异常)都算作方法结束。


![avatar](/resource/img/TIM图片20200519213321.png) 

# 本地方法区(线程私有)

>本地方法区和 Java Stack 作用类似, 区别是虚拟机栈为执行 Java 方法服务, 而本地方法栈则为
 Native 方法服务, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用, 那么该栈将会是一个
 C 栈,但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。
