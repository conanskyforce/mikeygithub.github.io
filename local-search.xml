<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Knife4j Tutorials</title>
    <link href="/2020/03/21/Knife4j-Tutorials/"/>
    <url>/2020/03/21/Knife4j-Tutorials/</url>
    
    <content type="html"><![CDATA[<h2 id="knife4j简介"><a href="#knife4j简介" class="headerlink" title="knife4j简介"></a>knife4j简介</h2><p>前身:swagger-bootstrap-ui</p><h3 id="swagger简介"><a href="#swagger简介" class="headerlink" title="swagger简介"></a>swagger简介</h3><blockquote><p>Swagger是一个API接口管理工具，支持在线测试接口数据，根据配置自动生成API文档，结合spring mvc而提供界面化方法文档的一个开源框架。</p></blockquote><p>Swagger主要的项目<br>Swagger是一组开源项目，主要项目如下：</p><ul><li>Swagger-tools:提供各种与Swagger进行集成和交互的工具。例如模式检验、Swagger 1.2文档转换成Swagger 2.0文档等功能。</li><li>Swagger-core: 用于Java/Scala的的Swagger实现。与JAX-RS(Jersey、Resteasy、CXF…)、Servlets和Play框架进行集成。</li><li>Swagger-js: 用于JavaScript的Swagger实现。</li><li>Swagger-node-express: Swagger模块，用于node.js的Express web应用框架。</li><li>Swagger-ui：一个无依赖的HTML、JS和CSS集合，可以为Swagger兼容API动态生成优雅文档。</li><li>Swagger-codegen：一个模板驱动引擎，通过分析用户Swagger资源声明以各种语言生成客户端代码。</li><li>Swagger-editor：可让使用者在浏览器里以YAML格式编辑Swagger API规范并实时预览文档。可以生成有效的Swagger JSON描述，并用于所有Swagger工具（代码生成、文档等等）中。</li></ul><h3 id="Swagger-Bootstrap-UI简介"><a href="#Swagger-Bootstrap-UI简介" class="headerlink" title="Swagger-Bootstrap-UI简介"></a>Swagger-Bootstrap-UI简介</h3><blockquote><p>Swagger-Bootstrap-UI是springfox-swagger的增强UI实现，为Java开发者在使用Swagger的时候，能拥有一份简洁、强大的接口文档体验。</p></blockquote><h2 id="knife4j特点"><a href="#knife4j特点" class="headerlink" title="knife4j特点"></a>knife4j特点</h2><p>文档说明：根据Swagger的规范说明，详细列出接口文档的说明，包括接口地址、类型、请求示例、请求参数、响应示例、响应参数、响应码等信息，使用swagger-bootstrap-ui能根据该文档说明，对该接口的使用情况一目了然。</p><p>在线调试：提供在线接口联调的强大功能，自动解析当前接口参数,同时包含表单验证，调用参数可返回接口响应内容、headers、Curl请求命令实例、响应时间、响应状态码等信息，帮助开发者在线调试，而不必通过其他测试工具测试接口是否正确,简介、强大。</p><h2 id="knife4j使用"><a href="#knife4j使用" class="headerlink" title="knife4j使用"></a>knife4j使用</h2><p>1.创建springboot项目</p><p>2.添加依赖</p><pre><code class="text">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;        &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;        &lt;!--在引用时请在maven中央仓库搜索最新版本号--&gt;        &lt;version&gt;2.0.2&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>3.配置类</p><pre><code class="java">@Configuration@EnableSwagger2@EnableKnife4j@Import(BeanValidatorPluginsConfiguration.class)public class SwaggerConfiguration {    @Bean(value = &quot;defaultApi2&quot;)    public Docket defaultApi2() {        Docket docket=new Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                //分组名称                .groupName(&quot;2.X版本&quot;)                .select()                //这里指定Controller扫描包路径                .apis(RequestHandlerSelectors.basePackage(&quot;com.swagger.bootstrap.ui.demo.new2&quot;))                .paths(PathSelectors.any())                .build();        return docket;    }　　private ApiInfo apiInfo() {   　　 return new ApiInfoBuilder()      　　  .title(&quot;大学生专业学科竞赛项目过程管理系统&quot;)        　　.description(&quot;大学生专业学科竞赛项目过程管理系统t文档&quot;)        　　.termsOfServiceUrl(&quot;&quot;)        　　.version(&quot;3.0.0&quot;)        　　.build();　　}}</code></pre><p>注解说明</p><p><code>@EnableSwagger2</code></p><p>该注解是Springfox-swagger框架提供的使用Swagger注解，该注解必须加</p><p><code>@EnableKnife4j</code></p><p>该注解是knife4j提供的增强注解,Ui提供了例如动态参数、参数过滤、接口排序等增强功能,如果你想使用这些增强功能就必须加该注解，否则可以不用加</p><p>4.访问</p><p>在浏览器输入地址：<code>http://[you_host]:[you_port]/doc.html</code></p><p> <img src="/resource/img/knife4j-1.jpg" srcset="/img/loading.gif" alt="avatar"></p><h2 id="knife4j资料"><a href="#knife4j资料" class="headerlink" title="knife4j资料"></a>knife4j资料</h2><p><a href="https://doc.xiaominfo.com/guide/useful.html" target="_blank" rel="noopener">文档</a></p><p><a href="https://gitee.com/xiaoym/swagger-bootstrap-ui-demo" target="_blank" rel="noopener">示例</a></p><p><a href="https://www.cnblogs.com/fby698/p/11581845.html" target="_blank" rel="noopener">博文</a></p>]]></content>
    
    
    <categories>
      
      <category>开发组件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口文档</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hyperledger Caliper 性能测试工具配置</title>
    <link href="/2020/03/20/Hyperledger-Caliper-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/03/20/Hyperledger-Caliper-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Caliper性能测试工具配置"><a href="#Caliper性能测试工具配置" class="headerlink" title="Caliper性能测试工具配置"></a>Caliper性能测试工具配置</h1><p>基本上都是根据官方doc进行操作，个别部分有坑。</p><p><a href="https://hyperledger.github.io/caliper/docs/1_Getting_Started.html" target="_blank" rel="noopener">官方doc</a></p><p>提前安装</p><blockquote><p>nodejs、node-gyp、docker、docker-compose</p></blockquote><h2 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h2><p><code>git clone https://github.com/hyperledger/caliper.git</code></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>进入caliper代码根目录，执行以下命令：<br><code>npm install</code><br><code>npm run repoclean</code><br><code>npm run bootstrap</code></p><h2 id="安装caliper"><a href="#安装caliper" class="headerlink" title="安装caliper"></a>安装caliper</h2><p>根据官网步骤进行安装。</p><p><a href="https://github.com/hyperledger/caliper/blob/master/packages/caliper-tests-integration/README.md" target="_blank" rel="noopener">安装步骤</a><br><code>cd ./packages/caliper-tests-integration</code></p><h4 id="开启Verdaccio"><a href="#开启Verdaccio" class="headerlink" title="开启Verdaccio"></a>开启Verdaccio</h4><p><code>npm run start_verdaccio</code></p><p>成功界面：<br><img src="/resource/img/Picture1.png" srcset="/img/loading.gif" alt="avatar"></p><h4 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h4><p><code>npm run publish_packages</code></p><h4 id="安装caliper-1"><a href="#安装caliper-1" class="headerlink" title="安装caliper"></a>安装caliper</h4><p><code>npm run install_cli</code></p><p>成功界面：<br><img src="/resource/img/Picture2.png" srcset="/img/loading.gif" alt="avatar"></p><h5 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h5><p>1.3.3.1.1.无权限<br>报错：gyp stack Error: EACCES: permission denied, mkdir ‘/usr/local/lib/node_modules/caliper…<br>原因：用户没有/usr/local/lib/node_modules/文件夹的写权限<br>解决方法：<br>（1）官方文档方法：修改npm的安装目录为一个本地用户有权限的目录，命令：<code>npm config set prefix ~/youdir</code>，修改后caliper会安装到此目录。<br>（2）我的方法：不想修改npm安装目录，并且我在root用户下进行的操作，怀疑安装过程中切换了用户。所以我修改了caliper安装命令，添加<code>--unsafe-perm</code>参数，避免用户切换。<br>修改文件：<code>packages/caliper-tests-integration/scripts/npm_install.js</code>第<code>65</code>行  </p><p>修改结果：  </p><p><img src="/resource/img/Picture3.png" srcset="/img/loading.gif" alt="avatar"></p><p>修改完后重新执行 <code>npm run install_cli</code>  </p><p>1.3.3.1.2.卡在<code>node-pre-gyp</code>命令</p><p>若一直卡在如下界面，重新执行<code>npm run install_cli</code>。百度说要vpn，我没有vpn，重新执行命令一样ok。  </p><p><img src="/resource/img/Picture4.png" srcset="/img/loading.gif" alt="avatar"></p><p>1.3.4.验证安装结果执行<code>caliper -v</code>，出现如下结果即安装成功</p><p><img src="/resource/img/Picture5.png" srcset="/img/loading.gif" alt="avatar"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>运行caliper提供的fabric1.4的sample。<br><code>cd packages/caliper-samples</code><br><code>caliper benchmark run -w ./ -c benchmark/simple/config.yaml -n network/fabric-v1.4/2org1peergoleveldb/fabric-ccp-go.yaml --caliper-core-skipendscript</code>  </p><p>成功界面：</p><p><img src="/resource/img/Picture6.png" srcset="/img/loading.gif" alt="avatar"></p><p><code>caliper-core-skipendscript</code>加上此参数，caliper执行完会跳过下图配置文件fabric-ccp-go.yaml的end的命令，不关闭fabric环境，这样有助于查看日志。不想保留fabric环境可不加此参数。</p><p><img src="/resource/img/Picture7.png" srcset="/img/loading.gif" alt="avatar"></p><p>Caliper运行日志记录在-w命令指定目录下的log目录中。</p><h2 id="官网的坑"><a href="#官网的坑" class="headerlink" title="官网的坑"></a>官网的坑</h2><p>1.5.1.千万不要执行<code>npm run cleanup</code></p><p><img src="/resource/img/Picture8.png" srcset="/img/loading.gif" alt="avatar"></p><p><code>npm run cleanup</code>执行过程中会删除安装的caliper，执行完此命令，在执行caliper -v会提示找不到命令。</p><p>1.5.2.不能执行One-step install</p><p><img src="/resource/img/Picture9.png" srcset="/img/loading.gif" alt="avatar"></p><p>官网One-step install如下：</p><p>One-step install也包含了npm run cleanup命令。所以安装完你依旧会看到如下界面：</p><p><img src="/resource/img/Picture10.png" srcset="/img/loading.gif" alt="avatar"></p><p>还是不要偷懒使用一步安装了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/hyperledger/caliper" target="_blank" rel="noopener">https://github.com/hyperledger/caliper</a><br><a href="https://hyperledger.github.io/caliper/docs/1_Getting_Started.html" target="_blank" rel="noopener">https://hyperledger.github.io/caliper/docs/1_Getting_Started.html</a><br><a href="https://github.com/hyperledger/caliper/blob/master/packages/caliper-tests-integration/README.md" target="_blank" rel="noopener">https://github.com/hyperledger/caliper/blob/master/packages/caliper-tests-integration/README.md</a>  </p>]]></content>
    
    
    <categories>
      
      <category>Hyperledger</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hyperledger Iroha</title>
    <link href="/2020/03/18/Hyperledger-Iroha/"/>
    <url>/2020/03/18/Hyperledger-Iroha/</url>
    
    <content type="html"><![CDATA[<h1 id="Hyperledger-Iroha-简介"><a href="#Hyperledger-Iroha-简介" class="headerlink" title="Hyperledger Iroha 简介"></a>Hyperledger Iroha 简介</h1><h2 id="1-1。Iroha的主要特征是什么？"><a href="#1-1。Iroha的主要特征是什么？" class="headerlink" title="1.1。Iroha的主要特征是什么？"></a>1.1。Iroha的主要特征是什么？</h2><ul><li>简单的部署和维护</li><li>面向开发人员的各种库</li><li>基于角色的访问控制</li><li>化设计，由命令-查询分离原理驱动</li><li>和身份管理  </li></ul><p>在我们的质量模型中，我们专注于并不断改进：</p><ul><li>性（容错性，可恢复性）</li><li>效率（尤其是时间行为和资源利用）</li><li>性（易学性，用户错误保护，适当性可识别性）</li></ul><h2 id="在哪里可以使用Iroha？"><a href="#在哪里可以使用Iroha？" class="headerlink" title="在哪里可以使用Iroha？"></a>在哪里可以使用Iroha？</h2><p>Hyperledger Iroha是通用许可的区块链系统，可用于管理数字资产，身份和序列化数据。这对于银行间结算，中央银行数字货币，支付系统，国家ID和物流等应用可能很有用。</p><p>有关详细说明，请检查我们的用例场景部分。</p><p>1.3。它与比特币或以太坊有何不同？<br>比特币和以太坊被设计为无人允许的分类帐，任何人都可以加入并访问所有数据。它们还具有与系统交互所需的本机加密货币。</p><p>在Iroha中，没有本机加密货币。相反，为了满足企业的需求，允许进行系统交互，这意味着只有具有必需访问权限的人才能与系统交互。此外，还允许查询，以便可以控制对所有数据的访问。</p><p>与以太坊的主要区别尤其在于，Hyperledger Iroha允许用户通过使用系统中的预构建命令来执行常见功能，例如创建和传输数字资产。这就消除了编写繁琐且难以测试的智能合约的需要，从而使开发人员能够更快，风险更低地完成简单的任务。</p><p>1.4。它与其他Hyperledger框架或其他许可的区块链有何不同？<br>Iroha具有一种新颖的，具有Crash容错能力的共识算法（称为YAC [1]），该算法具有很高的性能，并允许以低延迟完成事务。</p><p>此外，与其他平台相比，Iroha的内置命令是一个主要优点，因为执行诸如创建数字资产，注册帐户以及在帐户之间转移资产之类的常见任务非常简单。此外，由于故障少，它缩小了攻击媒介，提高了系统的整体安全性。</p><p>最后，Iroha是唯一具有强大权限系统的分类帐，允许为所有命令，查询和网络加入设置权限。</p><p>[1]    另一个共识<br>1.5。如何围绕Iroha创建应用程序？<br>为了将区块链的功能带入您的应用程序，您应该首先考虑它如何与Iroha同行进行接口。一个好的开始是检查“ 概念和体系结构”部分，解释什么是事务和查询，以及应用程序的用户应该如何与之交互。</p><p>我们也有几个客户端库，这些库为开发人员提供了形成构建块的工具，例如签名，命令，向Iroha对等方发送消息并检查状态。</p><p>Hyperledger Iroha 核心概念<br>Why Iroha runs in a network? How to understand the objects inside and outside the system? How peers in the network collaborate and decide which data to put into the blockchain? We will look through the basics of Iroha in this section.</p><ul><li>2.1.1. Account</li><li>2.1.2. Asset</li><li>2.1.3. Block</li><li>2.1.4. Client</li><li>2.1.5. Command</li><li>2.1.6. Consensus</li><li>2.1.7. Domain</li><li>2.1.8. Peer</li><li>2.1.9. Permission</li><li>2.1.10. Proposal</li><li>2.1.11. Query</li><li>2.1.12. Quorum</li><li>2.1.13. Role</li><li>2.1.14. Signatory</li><li>2.1.15. Transaction</li><li>2.1.16. Batch of Transactions</li><li>2.1.17. Multisignature Transactions</li><li>2.1.18. Validation</li><li>2.1.19. Entity-relationship model</li></ul><h1 id="Hyperledger-Iroha-内部组成"><a href="#Hyperledger-Iroha-内部组成" class="headerlink" title="Hyperledger Iroha 内部组成"></a>Hyperledger Iroha 内部组成</h1><p>HL Iroha网络由几个基本组件组成，这些组件提供节点之间的通信。您可以在下面了解它们。</p><h1 id="Iroha体系结构图"><a href="#Iroha体系结构图" class="headerlink" title="Iroha体系结构图"></a>Iroha体系结构图</h1><p>2.2.1。Torii<br>客户的切入点。使用gRPC作为传输。为了与Iroha进行交互，任何人都可以使用gRPC端点（如“ 命令和查询”部分中所述）或使用客户端库。</p><p>2.2.2。MST处理器<br>多签名交易处理器</p><p>这是一项内部gRPC服务，可通过Gossip协议发送和接收来自其他对等方的消息。它的任务是发出尚未收到足够签名以达到法定人数的多重签名交易。</p><p>2.2.3。对等通信服务<br>Iroha的内部组件- 通过MstProcessor将交易从Torii 传输到Ordering Gate的中介。PCS的主要目标是隐藏与共识实现交互的复杂性。</p><p>2.2.4。订购门<br>它是内部Iroha组件（gRPC客户端），可将事务从对等通信服务中继到订购服务。Ordering Gate 从Ordering Service 接收提案（链中的潜在模块），并将其发送到Simulator进行状态验证。它还根据共识回合要求订购服务提供建议。</p><p>2.2.5。订购服务<br>内部Iroha组件（gRPC服务器），该组件从其他对等方接收消息，并将已通过无状态验证传递的多个交易合并到投标中。每个节点都有其自己的订购服务。提案创建可以由以下事件之一触发：</p><p>专用于交易收集的期限已到期。<br>订购服务已收到单个提案允许的最大交易量。<br>这两个参数（超时和建议的最大大小）都是可配置的（请检查特定于环境的参数页面）。</p><p>这两个触发器的共同先决条件是至少一项交易应到达订购服务。否则，将不会形成任何建议。</p><p>订购服务还对提案进行初步验证（例如，从提案中清除无状态拒绝的交易）。</p><p>2.2.6。经过验证的提案创建者<br>内部Iroha组件，对订购服务收到的投标中包含的交易执行状态验证。基于已通过状态验证的事务，将创建经过验证的提议并将其传递给Block Creator。所有未通过状态验证的交易都将被删除，并且不包含在已验证的投标中。</p><p>2.2.7。块造物主<br>系统组件，它通过一系列已通过无状态和有状态验证的事务构成块，以便进一步传播到共识。</p><p>区块创建者与“ 验证提议创建者”一起构成了一个名为Simulator的组件。</p><p>2.2.8。区块共识（YAC）<br>共识，作为一个组成部分</p><p>共识是区块链的核心-它在对等网络中的对等之间保持一致的状态。Iroha使用自己的共识算法，称为“另一个共识”（又名YAC）。</p><p>您可以在此处观看视频，其中对共识和YAC的原理进行了详尽的解释。</p><p>YAC算法的显着特征是它的可伸缩性，性能和崩溃容错能力。</p><p>为了确保网络的一致性，如果缺少块，将通过Synchronizer从另一个对等方下载它们。提交的块存储在Ametsuchi块存储中。</p><p>有关共识的一般定义，请检查此链接。</p><p>2.2.9。同步器<br>是共识的一部分。将缺失的块添加到对等方的链中（从其他对等方下载它们以保持一致性）。</p><p>2.2.10。Ametsuchi Blockstore<br>Iroha存储组件，用于存储块和从块生成的状态，称为World State View。有没有办法让客户端直接与Ametsuchi互动。</p><p>2.2.11。世界状态视图<br>WSV反映了系统的当前状态，可以视为快照。例如，WSV保留有关帐户当前拥有的资产数量的信息 ，但不包含任何交易流的信息历史记录。 </p><h1 id="Hyperledger-Iroha-快速入门"><a href="#Hyperledger-Iroha-快速入门" class="headerlink" title="Hyperledger Iroha 快速入门"></a>Hyperledger Iroha 快速入门</h1><p>在本指南中，我们将创建一个非常基本的Iroha网络，启动它，创建几个事务，并检查写入分类帐中的数据。为简单起见，我们将使用Docker。</p><p>注意</p><p>Ledger是区块链的代名词，Hyperledger Iroha也被称为分布式Ledger技术框架-本质上与“区块链框架”相同。您可以检查“ 核心概念”部分中使用的其余术语。</p><p>3.1。前提条件<br>对于本指南，您需要一台Docker已安装的机器。您可以阅读如何在Docker网站上安装它。</p><p>注意</p><p>当然，您可以从头开始构建Iroha，修改其代码并启动自定义节点！如果您想知道如何做–您可以查看Building Iroha部分。在本指南中，我们将使用Iroha的标准发行版作为docker映像。</p><p>3.2。启动Iroha </p><p>3.2.1。创建一个Docker网络<br>要进行操作，Iroha需要一个PostgreSQL数据库。让我们从创建Docker网络开始，以便Postgres和Iroha的容器可以在同一虚拟网络上运行并成功通信。在本指南中，我们将其称为iroha-network，但您可以使用任何名称。在您的终端中输入以下命令：</p><p>泊坞窗网络创建iroha-network<br>3.2.2。启动PostgreSQL容器<br>现在，我们需要PostgreSQL在容器中运行，将其附加到之前创建的网络，并公开用于通信的端口：</p><pre><code>docker--name some-postgres\ -e POSTGRES_USER = postgres\ -e POSTGRES_PASSWORD = mysecretpassword \ -p 5432：5432 \ --network =iroha-network\ -d postgres：9.5 \ -c &#39;max_prepared_transactions = 100&#39;</code></pre><p>注意</p><p>如果已经在主机系统上的默认端口（5432）上运行了Postgres，则应选择另一个将被占用的空闲端口。例如5433：-p 5433:5432</p><p>3.2.3。创建Blockstore<br>在运行Iroha容器之前，我们可能会创建一个持久卷来存储文件，并为该链存储块。通过以下命令完成：</p><p>码头工人卷创建块存储<br>3.2.4。准备配置文件<br>注意</p><p>为简单起见，在本指南中，我们将创建一个仅包含单个节点的网络。要了解如何运行多个对等节点，请遵循部署</p><p>现在，我们需要配置Iroha网络。这包括创建配置文件，为用户生成密钥对，编写对等方列表以及创建创世块。</p><p>不要害怕-我们已经为本指南准备了一个示例配置，因此您可以立即开始测试Iroha节点。为了获取这些文件，您需要 从Github 克隆Iroha存储库或手动复制它们（不过克隆速度更快）。</p><p><code>git clone -b master https://github.com/hyperledger/iroha --depth = 1</code></p><p>暗示</p><p>–depth=1选项允许我们仅下载最新的提交并节省一些时间和带宽。如果要获取完整的提交历史记录，则可以忽略此选项。</p><p>关于如何设置参数以及如何根据您的环境和负载期望对其进行调整的指南：配置。目前我们不需要这样做。</p><p>3.2.5。启动Iroha容器<br>我们几乎准备启动我们的Iroha集装箱。您只需要知道配置文件的路径（从上述步骤开始）。</p><p>让我们使用以下命令在Docker容器中启动Iroha节点：</p><pre><code>docker run --name iroha \ -d \ -p 50051：50051 \ -v $ { pwd ） / iroha / example：/ opt / iroha_data \ -v blockstore：/ tmp / block_store \ --network = iroha-network \ - e KEY = &#39;node0&#39;  \hyperledger / iroha：latest</code></pre><p>如果成功启动节点，您将在启动容器的同一控制台中看到容器ID。</p><p>让我们详细了解一下此命令的作用：</p><pre><code>docker run --name iroha \ 创建一个容器 iroha-d \ 在后台运行容器-p 50051:50051 \ 公开用于与客户端通信的端口（我们将在以后使用）-v YOUR_PATH_TO_CONF_FILES:/opt/iroha_data \这就是我们如何将配置文件传递到docker容器的方法。示例目录在上面的代码块中指示。-v blockstore:/tmp/block_store \ 将持久性块存储（Docker卷）添加到容器中，以便在我们停止容器后不会丢失块--network=iroha-network \将我们的容器添加到先前创建的iroha-network 用于与PostgreSQL服务器通信的容器-e KEY=&#39;node0&#39; \-在此请指出一个密钥名称，该名称将标识允许其确认操作的节点。密钥应与上述配置文件一起放在目录中。hyperledger/iroha:latest是指向最新版本的图像的引用</code></pre><p>您可以通过运行查看日志。docker logs iroha</p><p>您可以尝试使用示例指南之一，以便将一些事务发送到Iroha并查询其状态。</p><h3 id="3-3。尝试其他指南"><a href="#3-3。尝试其他指南" class="headerlink" title="3.3。尝试其他指南"></a>3.3。尝试其他指南</h3><p>3.3.1。CLI指南：发送您的第一笔交易和查询<br>3.3.1.1。创建第一笔交易<br>3.3.1.2。创建第一个查询<br>3.3.1.3。成为坏蛋<br>3.3.2。使用Python库发送交易<br>3.3.2.1。先决条件<br>3.3.2.2。运行示例交易<br>3.3.2.3。定义命令<br>3.3.2.4。运行命令<br>Hyperledger 综合项目<br>Hyperledger联盟的想法之一是创建可以一起工作以提供最佳区块链体验的解决方案。在Iroha中，我们相信其他出色的Hyperledger工具和解决方案的集成是使Iroha更好地适合您的用例的一种方式。因此，我们致力于与多个项目的集成，并希望向您详细介绍Iroha可以与之合作的内容。</p><h3 id="4-1。Hyperledger-Ursa"><a href="#4-1。Hyperledger-Ursa" class="headerlink" title="4.1。Hyperledger Ursa"></a>4.1。Hyperledger Ursa</h3><p>Hyperledger Ursa是一个共享的密码库，使人们（和项目）可以避免重复其他密码工作，并希望在此过程中提高安全性。该库将是供项目（以及可能还有其他项目）放置和使用加密货币的可选存储库。Hyperledger Ursa由子项目组成，这些子项目是密码代码或密码代码接口的内聚实现。</p><p>通过在构建过程中仅添加一个标志，可以轻松地使用Ursa库构建Iroha 。它将允许您使用Ursa库中的加密算法代替标准的Iroha加密技术。随着Ursa中新图书馆的发展，将为您提供越来越多的选择！</p><h3 id="4-2。Hyperledger-Explorer"><a href="#4-2。Hyperledger-Explorer" class="headerlink" title="4.2。Hyperledger Explorer"></a>4.2。Hyperledger Explorer</h3><p>Hyperledger Explorer是一个区块链模块，是The Linux Foundation托管的Hyperledger项目之一。Hyperledger Explorer旨在创建一个用户友好的Web应用程序，可以查看，调用，部署或查询块，事务和相关数据，网络信息（名称，状态，节点列表），链代码和事务族，以及任何其他相关信息存储在分类帐中。</p><p>在这里，您可以了解如何将Explorer与Iroha结合使用。</p><h3 id="4-3。Hyperledger-Burrow"><a href="#4-3。Hyperledger-Burrow" class="headerlink" title="4.3。Hyperledger Burrow"></a>4.3。Hyperledger Burrow</h3><p>Hyperledger Burrow为模块化区块链客户端提供了一个经过许可的智能合约解释器，该解释器部分已按照以太坊虚拟机（EVM）的规范进行开发。</p><p>我们将很快准备有关如何使用Iroha中集成的Burrow的说明。</p><h1 id="绑定-Iroha"><a href="#绑定-Iroha" class="headerlink" title="绑定 Iroha"></a>绑定 Iroha</h1><p>In this guide we will learn how to install all dependencies, required to build Iroha and how to actually build it.</p><p>There will be 3 steps:</p><p>1.Installing environment prerequisites<br>2.Installing Iroha dependencies (will be performed automatically for Docker)<br>3.Building Iroha  </p><p>Note</p><p>You don’t need to build Iroha to start using it. Instead, you can download prepared Docker image from the Hub, this process explained in details in the Quick Start Guide page of this documentation.</p><p>5.1. Prerequisites<br>In order to successfully build Iroha, we need to configure the environment. There are several ways to do it and we will describe all of them.</p><p>Currently, we support Unix-like systems (we are basically targeting popular Linux distros and MacOS). If you happen to have Windows or you don’t want to spend time installing all dependencies you might want to consider using Docker environment. Also, Windows users might consider using WSL</p><p>Technically Iroha can be built under Windows natively in experimental mode. This guide covers that way too. All the stages related to native Windows build are separated from the main flow due to its significant differences.</p><p>Please choose your preferred platform below for a quick access:</p><ul><li>docker</li><li>linux</li><li>macOS</li><li>windows</li><li>Hint</li></ul><p>Having troubles? Check FAQ section or communicate to us directly, in case you were stuck on something. We don’t expect this to happen, but some issues with an environment are possible.</p><p>5.1.1. Docker<br>First of all, you need to install docker and docker-compose. You can read how to install it on the Docker’s website</p><p>Note</p><p>Please, use the latest available docker daemon and docker-compose.</p><p>Then you should clone the Iroha repository to the directory of your choice:</p><p><code>git clone -b master https://github.com/hyperledger/iroha --depth=1</code></p><p>Hint</p><p>–depth=1 option allows us to download only latest commit and save some time and bandwidth. If you want to get a full commit history, you can omit this option.</p><p>When it is done, you need to run the development environment. Run the scripts/run-iroha-dev.sh script:</p><p>bash scripts/run-iroha-dev.sh<br>Hint</p><p>Please make sure that Docker is running before executing the script. MacOS users could find a Docker icon in system tray, Linux users can use systemctl start docker</p><p>After you execute this script, the following things will happen:</p><p>The script will check whether you have containers with Iroha already running. Successful completion finishes with the new container shell.<br>The script will download hyperledger/iroha:develop-build and postgres images. hyperledger/iroha:develop-build image contains all development dependencies and is based on top of ubuntu:18.04. postgres image is required for starting and running Iroha.<br>Two containers are created and launched.<br>The user is attached to the interactive environment for development and testing with iroha folder mounted from the host machine. Iroha folder is mounted to /opt/iroha in Docker container.<br>Now your are ready to build Iroha! Please go directly to Building Iroha section.</p><p>5.1.2. Linux<br>To build Iroha, you will need the following packages:</p><p>build-essential git ca-certificates tar ninja-build curl unzip cmake</p><p>Use this code to install environment dependencies on Debian-based Linux distro.</p><pre><code>apt-get update; \apt-get -y --no-install-recommends install \build-essential ninja-build \git ca-certificates tar curl unzip cmake</code></pre><p>Note</p><p>If you are willing to actively develop Iroha and to build shared libraries, please consider installing the latest release of CMake.</p><p>Now you are ready to install Iroha dependencies.</p><p>5.1.3. MacOS<br>If you want to build Iroha from scratch and actively develop it, please use the following code to install all environment dependencies with Homebrew:</p><p><code>xcode-select --install</code><br><code>brew install cmake ninja git gcc@7</code></p><p>Hint</p><p>To install the Homebrew itself please run</p><p><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/homebrew/install/master/install)&quot;</code></p><p>Now you are ready to install Iroha dependencies.</p><p>5.1.4. Windows<br>Note</p><p>All the listed commands are designed for building 64-bit version of Iroha.</p><p>5.1.4.1. Chocolatey Package Manager<br>First of all you need Chocolatey package manager installed. Please refer the guide for chocolatey installation.</p><p>5.1.4.2. Building the Toolset<br>Install CMake, Git, Microsoft compilers via chocolatey being in Administrative mode of command prompt:</p><p>choco install cmake git visualstudio2019-workload-vctools ninja<br>PostgreSQL is not a build dependency, but it is recommended to install it now for the testing later:</p><p>choco install postgresql<br>Don’t forget the password you set!<br>Now you are ready to install Iroha dependencies.</p><p>5.2. Installing dependencies with Vcpkg Dependency Manager<br>Currently we use Vcpkg as a dependency manager for all platforms - Linux, Windows and MacOS. We use a fixed version of Vcpkg to ensure the patches we need will work.</p><p>That stable version can only be found inside the Iroha repository, so we will need to clone Iroha. The whole process is pretty similar for all platforms but the exact commands are slightly different.</p><p>5.2.1. Linux and MacOS<br>Run in terminal:</p><p><code>git clone https://github.com/hyperledger/iroha.git</code><br><code>iroha/vcpkg/build_iroha_deps.sh</code><br><code>vcpkg/vcpkg integrate install</code></p><p>After the installation of vcpkg you will be provided with a CMake build parameter like -DCMAKE_TOOLCHAIN_FILE=/path/to/vcpkg/scripts/buildsystems/vcpkg.cmake. Save it somewhere for later use and move to Building Iroha section.</p><p>5.2.2. Windows<br>Execute from Power Shell:</p><p><code>git clone https://github.com/hyperledger/iroha.git</code><br><code>powershell -ExecutionPolicy ByPass -File .\iroha\.packer\win\scripts\vcpkg.ps1 .\vcpkg .\iroha\vcpkg</code></p><p>After the installation of vcpkg you will be provided with a CMake build parameter like -DCMAKE_TOOLCHAIN_FILE=C:/path/to/vcpkg/scripts/buildsystems/vcpkg.cmake. Save it somewhere for later use and move to Building Iroha section.</p><p>Note</p><p>If you plan to build 32-bit version of Iroha - you will need to install all the mentioned librares above prefixed with x86 term instead of x64.</p><p>5.3. Build Process<br>5.3.1. Cloning the Repository<br>This step is currently unnecessary since you have already cloned Iroha in the previous step. But if you want, you can clone the Iroha repository to the directory of your choice.</p><p><code>git clone -b master https://github.com/hyperledger/iroha</code><br><code>cd iroha</code></p><p>Hint</p><p>If you have installed the prerequisites with Docker, you don’t need to clone Iroha again, because when you run run-iroha-dev.sh it attaches to Iroha source code folder. Feel free to edit source code files with your host environment and build it within docker container.</p><p>5.3.2. Building Iroha<br>To build Iroha, use these commands:</p><p><code>cmake -H. -Bbuild -DCMAKE_TOOLCHAIN_FILE=/path/to/vcpkg/scripts/buildsystems/vcpkg.cmake -G &quot;Ninja&quot;</code><br><code>cmake --build build --target irohad -- -j&lt;number of threads&gt;</code></p><p>Note</p><p>On Docker the path to a toolchain file is /opt/dependencies/scripts/buildsystems/vcpkg.cmake. In other environment please use the path you have got in previous steps.</p><p>Number of threads will be defined differently depending on the platform: - On Linux: via nproc. - On MacOS: with sysctl -n hw.ncpu. - On Windows: use echo %NUMBER_OF_PROCESSORS%.</p><p>Note</p><p>When building on Windows do not execute this from the Power Shell. Better use x64 Native tools command prompt.</p><p>Now Iroha is built. Although, if you like, you can build it with additional parameters described below.</p><p>5.3.3. CMake Parameters<br>We use CMake to generate platform-dependent build files. It has numerous flags for configuring the final build. Note that besides the listed parameters cmake’s variables can be useful as well. Also as long as this page can be deprecated (or just not complete) you can browse custom flags via cmake -L, cmake-gui, or ccmake.</p><p>Hint</p><blockquote><p>You can specify parameters at the cmake configuring stage (e.g cmake -DTESTING=ON).</p></blockquote><p>5.3.3.1. Main Parameters<br>Parameter    Possible values    Default    Description<br>TESTING    ON/OFF    ON    Enables or disables build of the tests<br>BENCHMARKING    OFF    Enables or disables build of the Google Benchmarks library<br>COVERAGE    OFF    Enables or disables lcov setting for code coverage generation<br>USE_LIBURSA    OFF    Enables usage of the HL Ursa cryptography instead of the standard one<br>Note</p><blockquote><p>If you would like to use HL Ursa cryptography for your build, please install Rust in addition to other dependencies. Learn more about HL Ursa integration here.</p></blockquote><p>5.3.3.2. Packaging Specific Parameters<br>Parameter    Possible values    Default    Description<br>PACKAGE_ZIP    ON/OFF    OFF    Enables or disables zip packaging<br>PACKAGE_TGZ    OFF    Enables or disables tar.gz packaging<br>PACKAGE_RPM    OFF    Enables or disables rpm packaging<br>PACKAGE_DEB    OFF    Enables or disables deb packaging<br>5.3.4. Running Tests (optional)<br>After building Iroha, it is a good idea to run tests to check the operability of the daemon. You can run tests with this code:</p><p><code>cmake --build build --target test</code><br>Alternatively, you can run the following command in the build folder</p><p><code>cd build</code><br><code>ctest . --output-on-failure</code><br>Note</p><blockquote><p>Some of the tests will fail without PostgreSQL storage running, so if you are not using scripts/run-iroha-dev.sh script please run Docker container or create a local connection with following parameters:</p></blockquote><pre><code>docker run --name some-postgres \-e POSTGRES_USER=postgres \-e POSTGRES_PASSWORD=mysecretpassword \-p 5432:5432 \-d postgres:9.5 \-c &#39;max_prepared_transactions=100&#39;</code></pre><h1 id="Hyperledger-Iroha-相关资料"><a href="#Hyperledger-Iroha-相关资料" class="headerlink" title="Hyperledger Iroha 相关资料"></a>Hyperledger Iroha 相关资料</h1><p><a href="https://iroha.readthedocs.io/en/latest/" target="_blank" rel="noopener">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>Hyperledger</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hyperledger Caliper</title>
    <link href="/2020/03/16/Hyperledger-Caliper/"/>
    <url>/2020/03/16/Hyperledger-Caliper/</url>
    
    <content type="html"><![CDATA[<h2 id="Caliper-简介"><a href="#Caliper-简介" class="headerlink" title="Caliper 简介"></a>Caliper 简介</h2><p>Caliper是一个区块链性能基准框架，允许用户使用自定义用例测试不同的区块链解决方案，并获得一组性能测试结果。</p><blockquote><p>Caliper is a blockchain benchmark framework which allows users to measure the performance of a specific blockchain implementation with a set of predefined use cases. Caliper will produce reports containing a number of performance indicators, such as TPS (Transactions Per Second), transaction latency, resource utilisation etc. The intent is for Caliper results to be used as a reference in supporting the choice of a blockchain implementation suitable for the user-specific use-cases. Given the variety of blockchain configurations, network setup, as well as the specific use-cases in mind, it is not intended to be an authoritative performance assessment, nor to be used for simple comparative purposes (e.g. blockchain A does 5 TPS and blockchain B does 10 TPS, therefore B is better). The Caliper project references the definitions, metrics, and terminology as defined by the Performance &amp; Scalability Working Group (PSWG).</p></blockquote><h2 id="适用平台"><a href="#适用平台" class="headerlink" title="适用平台"></a>适用平台</h2><ul><li>Hyperledger Besu  </li><li>Hyperledger Burrow</li><li>Ethereum  </li><li>Hyperledger Fabric</li><li>FISCO BCOS</li><li>Hyperledger Iroha</li><li>Hyperledger Sawtooth</li><li>Transaction/read throughput</li><li>Transaction/read latency (minimum, maximum, average, percentile)</li><li>Resource consumption (CPU, Memory, Network IO, …)</li></ul><h2 id="安装Caliper"><a href="#安装Caliper" class="headerlink" title="安装Caliper"></a>安装Caliper</h2><p>Caliper is published as the <code>hyperledger/caliper-cli</code> NPM package and the <code>hyperledger/caliper</code><br> Docker image, both containing the CLI binary. Refer to the<br>Installing from NPM<br> and<br>Using the Docker image<br> sections for the available versions and their intricacies.</p><p>Installing and running Caliper usually consists of the following steps, thoroughly detailed by the remaining sections:</p><p>Acquire the Caliper CLI either from NPM or from DockerHub.<br>Execute a bind command through the CLI. This step pulls the specified version of SDK packages for the selected platform.<br>Start the benchmark through the CLI or by starting the Docker container.<br>The examples in the rest of the documentation use the<br>caliper-benchmarks<br> repository as the Caliper workspace since it contains many sample artifacts for benchmarking. Make sure you check out the appropriate tag/commit of the repository, matching the version of Caliper you use.</p><p>To clone the caliper-benchmarks repository, run:</p><pre><code>git clone https://github.com/hyperledger/caliper-benchmarks.gitcd caliper-benchmarksgit checkout &lt;your Caliper version&gt;</code></pre><p><em>Note</em>: </p><blockquote><p>If you are running your custom benchmark, then change this directory path (and other related configurations) accordingly in the examples.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Hyperledger</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区块链</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
